const Op                    = require('../../operators');
// const sequelize             = require('../sequelize');


// const { Op } = sequelize;

module.exports = function({ Room, Apartment, Client }) {
  Room.handleBeforeCreate = async (room) => {
    const { ApartmentId, roomNumber } = room;
    const apartment = await Apartment.findById(ApartmentId);

    room.reference = `${apartment.reference}${roomNumber}`;
    room.name = `${apartment.name} - Chambre ${roomNumber}`;
    room.descriptionFr = Room.generateDescriptionFr({ room, apartment });
    room.descriptionEn = Room.generateDescriptionEn({ room, apartment });
  };
  Room.addHook('beforeCreate', (room, opts) =>
    Room.handleBeforeCreate(room, opts)
  );

  Room.hook('beforeDestroy', async (room) => {
    const clients = await Client.scope('currentApartment').findAll({
      where: {
        '$Rentings.RoomId$': room.id,
        '$Rentings.bookingDate$': { [Op.lte]:  new Date() },
      },
    });

    if ( clients.length > 0) {
      throw new Error('Cannot delete Room: it\'s not empty.');
    }

    return true;
  });

  // To simplify interaction with WordPress, alias findById to findByIdOrReference
  Room.hook('beforeFind', (options) => {
    let id;

    // simplify the where generated by the booking page
    try {
      id = options.where[Op.and].find((obj) => Op.and in obj)[Op.and][0].id[Op.eq];
    }
    catch (e) { id = null; }

    if ( typeof id === 'string' ) {
      options.where = { [Op.or]: [{ id }, { reference: id }] };
    }

    // It is safe to disable subqueries because it was used only with the default
    // segment which includes Rentings through the availableAt scope.
    // In this case, only a single Renting is ever returned.
    if ( options.subQuery === true ) {
      // Subqueries fail completely when using Renting related views.
      console.warning('Sequelize subqueries have been disabled for Room');
    }
    options.subQuery = false;

    return options;
  });
};
